# Основные термины

**Минимальная единица программы** — это **Задача**. Это элемент, представляющий собой отдельный шаг в процессе работы программы или взаимодействия пользователя с LLM. Каждая Задача имеет одну **родительскую задачу** и неограниченное количество **наследуемых задач**. Набор задач, у которых только один наследник, называется **веткой**. Ветка представляет собой линейную последовательность задач, где каждая задача имеет одно продолжение, что удобно для реализации простых и прямолинейных диалогов. Если в этом наборе хотя бы у одной задачи несколько наследников, тогда это называется **деревом**. Дерево обозначает более сложную структуру, где у задач может быть несколько продолжений, что позволяет разнообразить взаимодействие. Такие структуры идеально подходят для создания сложных диалоговых сценариев.

### Базовые виды задач:
- **Задача настройки (SetOptions)** — позволяет задать параметры взаимодействия.
- **Задача запроса (Request)** — формулирует вопросы к системе.
- **Задача ответа (Response)** — предоставляет ответы модели.

# Описание функционала

**Основной алгоритм использования программы** — это составление последовательной **цепочки из задач**. Цепочка представляет собой упорядоченный набор взаимосвязанных задач, которые следуют одна за другой в строгом порядке. Как правило, это цепочки запрос, ответ, запрос, ответ и так далее. Это имитирует естественный диалог между человеком и моделью. Пользователь может создавать различное количество таких цепочек, что дает ему большую гибкость в экспериментах и исследованиях.

**Второстепенный, но не менее важный алгоритм** — это редактирование цепочек. Для этого можно выбрать уже созданную задачу и добавить ей наследника. Это позволяет пользователю вторично использовать части диалогов и улучшать их. Например, если где-то в диалоге упоминается нумерованный список, то можно создавать уникальные запросы на каждый уникальный элемент списка, усиливая взаимодействие и позволяя прорабатывать темы более тщательно.

**Третичный алгоритм** — это комбинации различных частей деревьев между собой. Это позволяет комбинировать элементы разных деревьев для создания нового диалога, что значительно увеличивает степень наставимости системы. Например, использование уже не начальной части дерева, а конечных участков помогает извлекать наиболее полезные части готовых задач. Если вам часто требуется превращать данные в JSON формат, вы можете просто копировать соответствующий диалог по мере необходимости, что ускоряет рабочий процесс и делает его более эффективным.

Благодаря таким алгоритмам программа становится универсальным инструментом для создания сложных и гибких систем взаимодействия с пользователем, превращая рутинное взаимодействие с LLM в более динамичное и продуктивное.

Для обеспечения гибкости и удобства работы с программой, пользователи могут не только создавать цепочки задач, но и организовывать их в структуры, такие как деревья и ветки. Это обеспечивает возможность охватывать различные темы и диалоговые сценарии, что создаёт необходимость в управлении этими структурами. В следующем разделе представим функционал создания новых деревьев диалогов и управления задачами, что позволит пользователям эффективно работать с уже существующими данными.




### Описание функционала программы

Чтобы создать новое дерево диалогов, необходимо нажать кнопку **Create tree**. Эта кнопка инициирует процесс создания нового диалога, который будет функционировать независимо от уже существующих. Создание нового дерева позволяет пользователю начинать новую тему обсуждения без необходимости стирать предыдущие результаты работы.

**Инструкция по удалению задач** включает несколько шагов. Во-первых, перейдите на интересующее сообщение, используя кнопки навигации, которые позволяют перемещаться между различными задачами и сообщениями в диалоге. Затем перейдите на вкладку **Cmds**, которая содержит команды для выполнения различных действий с задачами и сообщениями. Наличие специализированной вкладки облегчает пользователям поиск нужных операций.

На вкладке Cmds нажмите на одну из кнопок, чтобы выполнить действие. Например, вы можете нажать на кнопку **Delete** для удаления задачи из текущего диалога, однако использование этой кнопки должно быть осознанным, чтобы избежать случайной потери информации. Необходимо учитывать, что удаление задачи повлечет нарушение связанной с ней логикой. Если необходимо удалить задачу, но сохранить логическую связь между остальными задачами, нажмите на кнопку **Extract**. Эта команда позволяет удалить задачу и автоматически соединить ветки в месте удаления.

Для удаления ветки до момента ветвления используйте кнопку **Remove branch**. Эта команда позволяет врачу удалить целую ветку диалога, начиная с определенного момента и не трогая дальнейшие ответвления. Это полезно для очистки диалогов, которые больше не имеют смысла. Если требуется полное удаление всего дерева диалога, используйте кнопку **Remove tree**. Эта команда выполняет полное уничтожение дерева с его ветвями и задачами, что требует осторожного подхода, так как вы утратите все данные, связанные с деревом.

Кроме того, программа позволяет создавать резервные копии проектов. Для этого следуйте инструкции по созданию быстрого сохранения проекта. Нажмите кнопку **Save to reserved**. Эта команда инициирует сохранение проекта в резервной копии и обеспечивает дополнительную безопасность информации. На две директории ниже создастся папка **tt_temp** с файлом вашего проекта, что позволяет легко найти сохраненное состояние в будущем.

Для восстановления проекта из сохраненной резервной копии просто нажмите **Restore reserved**. Эта команда позволяет вернуть проект в состояние на момент последнего сохранения, что помогает избежать потери информации и упрощает работу с ранее созданными проектами. 

Таким образом, описанные функции делают программу универсальным инструментом для управления диалогами, предоставляя возможности как для их редактирования, так и для эффективного сохранения и восстановления информации.

Чтобы лучше понять, как программа может удовлетворить потребности пользователей, следует рассмотреть её преимущества и недостатки. В этом контексте важно отметить, что функционал, описанный ранее, ориентирован на продвинутых пользователей, таких как промпт инженеры, которые стремятся к эффективности в работе с языковыми моделями. Теперь подробнее обсудим, что именно выделяет данный проект на фоне других решений и какие аспекты могут стать препятствием для его использования.

